<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>금연사업 지침 문의 Chatbot</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'brand-bg': '#131314',
              'brand-surface': '#1e1f20',
              'brand-primary': '#8ab4f8',
              'brand-secondary': '#4e5052',
              'brand-text-primary': '#e8eaed',
              'brand-text-secondary': '#bdc1c6',
            }
          }
        }
      }
    </script>
    <script type="importmap">
    {
      "imports": {
        "@google/genai": "https://aistudiocdn.com/@google/genai@^1.16.0"
      }
    }
    </script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
      // Set worker source for pdf.js from CDN
      pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
    </script>
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore-compat.js"></script>
  </head>
  <body class="bg-brand-bg text-brand-text-primary">
    <div id="root"></div>
    <script>
      // WARNING: Do not expose your API key in production.
      // This is for demonstration purposes only.
      window.process = {
        env: {
          API_KEY: 'AIzaSyCQHIDHCFKit9tGZuWgW82aFWNrY6AM5XU'
        }
      }
    </script>
    <script type="text/babel" data-type="module">
      import { GoogleGenAI } from "@google/genai";

      const { useState, useCallback, useMemo, useRef, useEffect, StrictMode } = React;

      // --- Inlined from types.ts ---
      const Role = {
        USER: 'user',
        MODEL: 'model',
      };
      
      // --- Inlined from services/geminiService.ts ---
      if (!process.env.API_KEY) {
          throw new Error("API_KEY environment variable not set");
      }
      const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
      const SYSTEM_INSTRUCTION_TEMPLATE = `You are an expert assistant. Your name is NotebookLM Assistant. 
      You must answer questions based ONLY on the following source material provided. 
      Do not use any external knowledge or your pre-trained knowledge. 
      If the answer cannot be found in the source material, you must state that the information is not available in the provided context. 
      Be concise, helpful, and cite which part of the source you are referring to if possible.

      Here is the source material:
      ---START OF SOURCE---
      {sourceText}
      ---END OF SOURCE---`;

      function createNotebookChatSession(sourceText) {
          const systemInstruction = SYSTEM_INSTRUCTION_TEMPLATE.replace('{sourceText}', sourceText);

          const chat = ai.chats.create({
              model: 'gemini-2.5-flash',
              config: {
                  systemInstruction: systemInstruction,
              },
              history: [],
          });
          return chat;
      }

      // --- Inlined from components/icons/UserIcon.tsx ---
      const UserIcon = ({ className = "w-6 h-6" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 24 24" fill="currentColor">
              <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z" />
          </svg>
      );

      // --- Inlined from components/icons/BotIcon.tsx ---
      const BotIcon = ({ className = "w-6 h-6" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 24 24" fill="currentColor">
              <path d="M19.98 10.98c0-4.96-4.02-8.98-8.98-8.98S2 6.02 2 10.98v3.03c0 .54.44.99.99.99h1.01V12h-2c0-4.41 3.59-8 8-8s8 3.59 8 8v2.01h-2v-2.01c0-.54-.44-.99-.99-.99H18v2.01h2v-2.04zM12 15c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm1.5-1.5c0-.83-.67-1.5-1.5-1.5S12 10.67 12 11.5s.67 1.5 1.5 1.5.5-.67.5-1.5z" opacity=".3" />
              <path d="M21 12v-1.02c0-4.96-4.02-8.98-8.98-8.98S3.04 6.02 3.04 10.98V12H2v2.01h1.05v2.99c0 .54.44.99.99.99H6v-2.01H4.04v-2.99H20v2.99h-2.01V20h2.01c.54 0 .99-.44.99-.99v-2.99H22V12h-1zm-9 3c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm1.5-1.5c0-.83-.67-1.5-1.5-1.5S10.5 10.67 10.5 11.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5z" />
          </svg>
      );

      // --- Inlined from components/icons/SendIcon.tsx ---
      const SendIcon = ({ className = "w-6 h-6" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 24 24" fill="currentColor">
              <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z" />
          </svg>
      );
      
      // --- Inlined from components/icons/DocumentIcon.tsx ---
      const DocumentIcon = ({ className = "w-6 h-6" }) => (
        <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m-1.5 0-3.75 3.75m3.75-3.75V4.5m0 13.5h-3a1.5 1.5 0 0 1-1.5-1.5v-10.5a1.5 1.5 0 0 1 1.5-1.5h3.75a1.5 1.5 0 0 1 1.5 1.5v10.5a1.5 1.5 0 0 1-1.5-1.5h-3.75Z" />
        </svg>
      );

      // --- Inlined from components/icons/LinkIcon.tsx ---
      const LinkIcon = ({ className = "w-6 h-6" }) => (
        <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" d="M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244" />
        </svg>
      );

      // --- Inlined from components/icons/GearIcon.tsx ---
      const GearIcon = ({ className = "w-6 h-6" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.324.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 0 1 1.37.49l1.296 2.247a1.125 1.125 0 0 1-.26 1.431l-1.003.827c-.293.24-.438.613-.438.995s.145.755.438.995l1.003.827c.48.398.668 1.03.26 1.431l-1.296 2.247a1.125 1.125 0 0 1-1.37.49l-1.217-.456c-.355-.133-.75-.072-1.075.124a6.57 6.57 0 0 1-.22.127c-.332.183-.582.495-.645.87l-.213 1.281c-.09.543-.56.94-1.11.94h-2.593c-.55 0-1.02-.398-1.11-.94l-.213-1.281c-.063-.374-.313-.686-.645-.87a6.52 6.52 0 0 1-.22-.127c-.324-.196-.72-.257-1.075-.124l-1.217.456a1.125 1.125 0 0 1-1.37-.49l-1.296-2.247a1.125 1.125 0 0 1 .26-1.431l1.003-.827c.293.24.438.613.438.995s-.145-.755-.438-.995l-1.003-.827a1.125 1.125 0 0 1-.26-1.431l1.296-2.247a1.125 1.125 0 0 1 1.37-.49l1.217.456c.355.133.75.072 1.075-.124.073-.044.146-.087.22-.127.332-.183.582-.495.645-.87l.213-1.281z" />
              <path strokeLinecap="round" strokeLinejoin="round" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0z" />
          </svg>
      );

      // --- Inlined from components/icons/TrashIcon.tsx ---
      const TrashIcon = ({ className = "w-6 h-6" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.124-2.033-2.124H8.033c-1.124 0-2.033.944-2.033 2.124v.916m7.5 0a48.667 48.667 0 0 0-7.5 0" />
          </svg>
      );

      // --- Updated Component: SourceInfo ---
      const SourceInfo = ({
          isLoading,
          sources,
          isEditMode,
          onToggleEditMode,
          tempSources,
          onUpdateTempSource,
          onRemoveTempSource,
          onAddTempSource,
          onSave,
          onCancel,
          onReset,
      }) => {
          const [newSourceName, setNewSourceName] = useState('');
          const [newSourceUrl, setNewSourceUrl] = useState('');

          const getSourceName = (url) => {
              try {
                  const parsedUrl = new URL(url);
                  const path = parsedUrl.pathname;
                  const filename = decodeURIComponent(path.split('/').pop() || '');
                  if (filename) return filename;
                  return parsedUrl.hostname;
              } catch (e) {
                  return url;
              }
          };

          const handleAdd = (e) => {
              e.preventDefault();
              const trimmedUrl = newSourceUrl.trim();
              if (trimmedUrl) {
                  const finalName = newSourceName.trim() || getSourceName(trimmedUrl);
                  onAddTempSource(finalName, trimmedUrl);
                  setNewSourceName('');
                  setNewSourceUrl('');
              }
          };

          const isPdf = (url) => url.toLowerCase().endsWith('.pdf');

          return (
              <div className="flex flex-col h-full bg-brand-surface rounded-lg p-4">
                  <div className="flex justify-between items-center mb-3">
                      <h2 className="text-lg font-semibold text-brand-primary">자료 출처</h2>
                      <button
                          onClick={onToggleEditMode}
                          className="p-1.5 text-brand-text-secondary hover:text-brand-text-primary hover:bg-brand-secondary/50 rounded-full transition-colors"
                          aria-label={isEditMode ? "Finish editing sources" : "Edit sources"}
                      >
                          <GearIcon className="w-5 h-5" />
                      </button>
                  </div>

                  {isEditMode ? (
                      <div className="flex flex-col flex-1 min-h-0">
                          <p className="text-sm text-brand-text-secondary mb-4">
                              자료를 수정하면 현재 채팅 세션이 초기화됩니다. 변경사항은 모든 사용자에게 적용되며 영구적으로 저장됩니다.
                          </p>
                          <div className="flex-1 overflow-y-auto pr-2 -mr-2 space-y-2">
                              {tempSources.map((source, index) => (
                                  <div key={index} className="flex items-center gap-2">
                                      <input
                                          type="text"
                                          value={source.name}
                                          onChange={(e) => onUpdateTempSource(index, 'name', e.target.value)}
                                          className="w-1/3 bg-brand-bg border border-brand-secondary rounded-md py-1.5 px-3 text-sm text-brand-text-primary focus:outline-none focus:ring-2 focus:ring-brand-primary"
                                          placeholder="출처명"
                                      />
                                       <input
                                          type="text"
                                          value={source.url}
                                          onChange={(e) => onUpdateTempSource(index, 'url', e.target.value)}
                                          className="flex-1 bg-brand-bg border border-brand-secondary rounded-md py-1.5 px-3 text-sm text-brand-text-primary focus:outline-none focus:ring-2 focus:ring-brand-primary"
                                          placeholder="URL"
                                      />
                                      <button
                                          onClick={() => onRemoveTempSource(index)}
                                          className="p-1.5 text-red-400 hover:bg-red-400/20 rounded-full transition-colors"
                                          aria-label="Remove source"
                                      >
                                          <TrashIcon className="w-5 h-5" />
                                      </button>
                                  </div>
                              ))}
                          </div>

                          <form onSubmit={handleAdd} className="flex gap-2 mt-4">
                               <input
                                  type="text"
                                  value={newSourceName}
                                  onChange={(e) => setNewSourceName(e.target.value)}
                                  className="w-1/3 bg-brand-bg border border-brand-secondary rounded-full py-2 px-4 text-sm text-brand-text-primary focus:outline-none focus:ring-2 focus:ring-brand-primary"
                                  placeholder="출처명 (선택 사항)"
                              />
                              <input
                                  type="text"
                                  value={newSourceUrl}
                                  onChange={(e) => setNewSourceUrl(e.target.value)}
                                  className="flex-1 bg-brand-bg border border-brand-secondary rounded-full py-2 px-4 text-sm text-brand-text-primary focus:outline-none focus:ring-2 focus:ring-brand-primary"
                                  placeholder="URL 추가 (PDF 또는 웹페이지)"
                              />
                              <button
                                  type="submit"
                                  className="px-4 py-2 bg-brand-primary text-brand-bg rounded-full text-sm font-semibold hover:bg-opacity-90 transition-colors disabled:opacity-50"
                                  disabled={!newSourceUrl.trim()}
                              >
                                  추가
                              </button>
                          </form>

                          <div className="flex justify-end gap-2 mt-4 pt-4 border-t border-brand-secondary">
                              <button onClick={onReset} className="px-4 py-2 bg-red-600/80 text-white rounded-full text-sm font-semibold hover:bg-red-600 transition-colors">
                                  기본값으로
                              </button>
                              <button onClick={onCancel} className="px-4 py-2 bg-brand-secondary text-brand-text-primary rounded-full text-sm font-semibold hover:bg-opacity-80 transition-colors">
                                  취소
                              </button>
                              <button onClick={onSave} className="px-4 py-2 bg-brand-primary text-brand-bg rounded-full text-sm font-semibold hover:bg-opacity-90 transition-colors">
                                  저장 및 새로고침
                              </button>
                          </div>
                      </div>
                  ) : (
                      <>
                          {isLoading ? (
                              <div className="flex flex-col items-center justify-center flex-1">
                                  <div className="w-8 h-8 border-4 border-brand-primary border-t-transparent rounded-full animate-spin mb-4"></div>
                                  <p className="text-brand-text-primary">자료 로딩 중...</p>
                                  <p className="text-sm text-brand-text-secondary">챗봇을 위해 자료를 준비하고 있습니다.</p>
                              </div>
                          ) : (
                              <div className="flex-1 overflow-y-auto">
                                  <p className="text-sm text-brand-text-secondary mb-4">
                                      챗봇은 아래 자료들을 기반으로 답변합니다.
                                  </p>
                                   <ul className="space-y-3">
                                      {sources.map((source, index) => {
                                          const sourceIsPdf = isPdf(source.url);
                                          return (
                                          <li key={index} className="flex items-start gap-3 text-brand-text-secondary text-sm">
                                              <div className="mt-0.5">
                                                {source.status === 'loading' && <div className="w-5 h-5 border-2 border-brand-secondary border-t-brand-primary rounded-full animate-spin"></div>}
                                                
                                                {source.status === 'loaded' && (sourceIsPdf 
                                                    ? <DocumentIcon className="w-5 h-5 flex-shrink-0 text-green-400" /> 
                                                    : <LinkIcon className="w-5 h-5 flex-shrink-0 text-green-400" />
                                                )}

                                                {source.status === 'error' && (sourceIsPdf 
                                                    ? <DocumentIcon className="w-5 h-5 flex-shrink-0 text-red-400" /> 
                                                    : <LinkIcon className="w-5 h-5 flex-shrink-0 text-red-400" />
                                                )}
                                              </div>
                                              <div className="flex-1 min-w-0">
                                                  <span className="text-brand-text-primary font-medium break-words">{source.name}</span>
                                                  {source.status === 'error' && <span className="block text-xs text-red-400 mt-1">오류: {source.errorMsg}</span>}
                                              </div>
                                          </li>
                                          );
                                      })}
                                  </ul>
                              </div>
                          )}
                      </>
                  )}
              </div>
          );
      };
      
      // --- Inlined from components/Message.tsx ---
      const Message = ({ message }) => {
          const isUser = message.role === Role.USER;

          return (
              <div className={`flex items-start gap-4 p-4 ${isUser ? '' : 'bg-brand-surface/50 rounded-lg'}`}>
                  <div className={`flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center ${isUser ? 'bg-brand-secondary' : 'bg-brand-primary'}`}>
                      {isUser ? <UserIcon className="w-5 h-5 text-brand-text-primary" /> : <BotIcon className="w-5 h-5 text-brand-bg" />}
                  </div>
                  <div className="flex-1 pt-1">
                      <p className="font-semibold text-brand-text-primary mb-1">{isUser ? 'You' : 'Assistant'}</p>
                      <p className="text-brand-text-secondary whitespace-pre-wrap">{message.content}</p>
                  </div>
              </div>
          );
      };
      
      // --- Inlined from components/MessageInput.tsx ---
      const MessageInput = ({ currentMessage, setCurrentMessage, onSendMessage, isLoading, disabled }) => {
          const isInputDisabled = isLoading || disabled;

          return (
              <form onSubmit={onSendMessage} className="p-4 bg-brand-surface">
                  <div className="relative">
                      <input
                          type="text"
                          value={currentMessage}
                          onChange={(e) => setCurrentMessage(e.target.value)}
                          placeholder={disabled ? "자료를 로딩 중입니다..." : "질문을 입력하세요..."}
                          disabled={isInputDisabled}
                          className="w-full bg-brand-bg border border-brand-secondary rounded-full py-3 pl-4 pr-12 text-brand-text-primary focus:outline-none focus:ring-2 focus:ring-brand-primary disabled:opacity-50"
                      />
                      <button
                          type="submit"
                          disabled={isInputDisabled || !currentMessage}
                          className="absolute right-2 top-1/2 -translate-y-1/2 p-2 rounded-full text-brand-primary hover:bg-brand-primary/20 disabled:text-brand-secondary disabled:hover:bg-transparent transition-colors"
                      >
                          <SendIcon className="w-6 h-6" />
                      </button>
                  </div>
              </form>
          );
      };

      // --- Inlined from components/ChatWindow.tsx ---
      const ChatWindow = ({ messages, isLoading, sourceProvided, isParsingDocs }) => {
          const scrollRef = useRef(null);

          useEffect(() => {
              if (scrollRef.current) {
                  scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
              }
          }, [messages, isLoading]);

          return (
              <div ref={scrollRef} className="flex-1 overflow-y-auto p-4 space-y-4">
                   {messages.length === 0 && isParsingDocs && (
                        <div className="text-center text-brand-text-secondary p-8 flex flex-col items-center justify-center h-full">
                            <div className="w-8 h-8 border-4 border-brand-primary border-t-transparent rounded-full animate-spin mb-4"></div>
                            <h3 className="text-xl font-semibold text-brand-text-primary">자료 로딩 중</h3>
                            <p>챗봇을 시작하기 위해 문서를 준비하고 있습니다.</p>
                        </div>
                   )}
                   {messages.length === 0 && !isParsingDocs && !sourceProvided && (
                        <div className="text-center text-brand-text-secondary p-8 flex flex-col items-center justify-center h-full">
                            <DocumentIcon className="w-12 h-12 mb-4 text-brand-secondary" />
                            <h3 className="text-xl font-semibold text-brand-text-primary">자료 없음</h3>
                            <p>답변의 기반이 될 자료가 없습니다. 좌측 패널에서 자료를 추가해주세요.</p>
                        </div>
                   )}
                   {messages.length === 0 && !isParsingDocs && sourceProvided && (
                      <div className="text-center text-brand-text-secondary p-8 flex flex-col items-center">
                          <BotIcon className="w-12 h-12 mb-4 text-brand-primary" />
                          <h3 className="text-xl font-semibold text-brand-text-primary">채팅 준비 완료</h3>
                          <p>문서가 로드되었습니다. 질문을 시작하세요.</p>
                      </div>
                  )}
                  {messages.map((msg, index) => (
                      <Message key={index} message={msg} />
                  ))}
                  {isLoading && messages.length > 0 && messages[messages.length - 1].role === 'user' && (
                       <div className="flex items-start gap-4 p-4 bg-brand-surface/50 rounded-lg">
                          <div className="flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center bg-brand-primary">
                              <BotIcon className="w-5 h-5 text-brand-bg" />
                          </div>
                          <div className="flex-1 pt-1">
                              <p className="font-semibold text-brand-text-primary mb-1">Assistant</p>
                              <div className="flex items-center gap-2">
                                  <span className="w-2 h-2 bg-brand-text-secondary rounded-full animate-pulse [animation-delay:-0.3s]"></span>
                                  <span className="w-2 h-2 bg-brand-text-secondary rounded-full animate-pulse [animation-delay:-0.15s]"></span>
                                  <span className="w-2 h-2 bg-brand-text-secondary rounded-full animate-pulse"></span>
                              </div>
                          </div>
                      </div>
                  )}
              </div>
          );
      };

      // --- Inlined from App.tsx ---
      const App = () => {
          const [sourceText, setSourceText] = useState('');
          const [messages, setMessages] = useState([]);
          const [currentMessage, setCurrentMessage] = useState('');
          const [isLoading, setIsLoading] = useState(false);
          const [isParsing, setIsParsing] = useState(true);
          const [sources, setSources] = useState([]);
          const [isEditMode, setIsEditMode] = useState(false);
          const [tempSources, setTempSources] = useState([]);
          const [error, setError] = useState(null);

          const firebaseConfig = {
            apiKey: "AIzaSyAvdOyBT1Zk9rZ79nP2RvdhpfpIQjGfw8Q",
            authDomain: "chat-4c3a7.firebaseapp.com",
            projectId: "chat-4c3a7",
            storageBucket: "chat-4c3a7.appspot.com",
            messagingSenderId: "995636644973",
            appId: "1:995636644973:web:59554144cbaad5d1444364",
            measurementId: "G-9T5TLP4SF1"
          };

          const firebaseApp = useMemo(() => {
              if (!firebase.apps.length) {
                  return firebase.initializeApp(firebaseConfig);
              }
              return firebase.app();
          }, []);

          const db = useMemo(() => firebase.firestore(firebaseApp), [firebaseApp]);
          const sourcesDocRef = useMemo(() => db.collection('settings').doc('sources'), [db]);

          const PDF_BASE_URL = 'https://ggawoos-bot.github.io/chat/pdf/';

          const chatSession = useMemo(() => {
              if (sourceText.trim()) {
                  try {
                    return createNotebookChatSession(sourceText);
                  } catch (e) {
                    console.error("Error creating chat session:", e);
                    setError(e instanceof Error ? e.message : "Failed to create chat session.");
                    return null;
                  }
              }
              return null;
          }, [sourceText]);
          
          const getSourceName = (url) => {
              try {
                  const parsedUrl = new URL(url);
                  const path = parsedUrl.pathname;
                  const filename = decodeURIComponent(path.split('/').pop() || '');
                  if (filename) return filename;
                  return parsedUrl.hostname;
              } catch (e) {
                  return url;
              }
          };

          const parsePdfFromUrl = async (url) => {
              try {
                  const pdfData = await fetch(url).then(res => {
                      if (!res.ok) {
                          throw new Error(`Failed to fetch (${res.status})`);
                      }
                      return res.arrayBuffer();
                  });
                  const pdf = await pdfjsLib.getDocument({ data: new Uint8Array(pdfData) }).promise;
                  let fullText = '';
                  for (let i = 1; i <= pdf.numPages; i++) {
                      const page = await pdf.getPage(i);
                      const textContent = await page.getTextContent();
                      const pageText = textContent.items.map(item => item.str).join(' ');
                      fullText += pageText + '\n\n';
                  }
                  return fullText;
              } catch (err) {
                  console.error(`Error parsing PDF from ${url}:`, err);
                  throw new Error(err.message || 'Unknown parsing error');
              }
          };

          const parseHtmlFromUrl = async (url) => {
              try {
                  const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
                  const response = await fetch(proxyUrl);
                  
                  if (!response.ok) {
                      throw new Error(`Failed to fetch page via proxy (${response.status})`);
                  }
                  
                  const htmlText = await response.text();
                  const parser = new DOMParser();
                  const doc = parser.parseFromString(htmlText, "text/html");
                  
                  doc.body.querySelectorAll('script, style, nav, header, footer, aside').forEach(el => el.remove());
                  return doc.body.textContent || "";
              } catch (err) {
                  console.error(`Error parsing HTML from ${url}:`, err);
                  throw new Error('콘텐츠를 가져올 수 없습니다. URL이 유효한지 또는 일시적인 문제가 아닌지 확인해주세요.');
              }
          };

          const loadSources = useCallback(async (sourceList) => {
              if (!sourceList || sourceList.length === 0) {
                  setSourceText('');
                  setSources([]);
                  setIsParsing(false);
                  return;
              }

              setIsParsing(true);
              setError(null);
              setSourceText('');
              setMessages([]);

              const updatedSources = sourceList.map(s => ({ ...s, status: 'loading', errorMsg: undefined }));
              setSources(updatedSources);

              const parsingPromises = updatedSources.map(async (source, index) => {
                  try {
                      const isPdf = source.url.toLowerCase().endsWith('.pdf');
                      const text = isPdf
                          ? await parsePdfFromUrl(source.url)
                          : await parseHtmlFromUrl(source.url);

                      setSources(prev => prev.map((s, i) => i === index ? { ...s, status: 'loaded' } : s));
                      return text;
                  } catch (err) {
                      setSources(prev => prev.map((s, i) => i === index ? { ...s, status: 'error', errorMsg: err.message } : s));
                      return null;
                  }
              });
              
              const texts = await Promise.all(parsingPromises);
              const validTexts = texts.filter(t => t && t.trim() !== '');
              
              if (validTexts.length > 0) {
                  const combinedText = validTexts.join('\n--- END OF DOCUMENT ---\n\n--- START OF DOCUMENT ---\n');
                  setSourceText(combinedText);
              } else {
                  setSourceText('');
                  if(sources.every(s => s.status === 'error')) {
                    setError("모든 자료를 불러오는 데 실패했습니다. URL을 확인하거나 다른 자료를 시도해주세요.");
                  }
              }

              setIsParsing(false);
          }, []);
          
          const discoverAndLoadInitialPdfs = useCallback(async () => {
              setIsParsing(true);
              try {
                  const manifestUrl = `${PDF_BASE_URL}manifest.json`;
                  const manifestResponse = await fetch(manifestUrl);
                  if (!manifestResponse.ok) throw new Error(`Could not load manifest.json`);
                  
                  const pdfFiles = await manifestResponse.json();
                  if (!Array.isArray(pdfFiles)) throw new Error("Invalid manifest.json format.");
                  
                  const initialSources = pdfFiles.map(file => {
                    const url = PDF_BASE_URL + file;
                    return { name: getSourceName(url), url };
                  });
                  setTempSources(initialSources);
                  loadSources(initialSources);

              } catch (err) {
                  console.error("Error loading initial PDFs:", err);
                  setError(err.message);
                  setSources([]);
                  setIsParsing(false);
              }
          }, [loadSources]);

          useEffect(() => {
              const loadInitialData = async () => {
                  try {
                      const docSnap = await sourcesDocRef.get();
                      if (docSnap.exists()) {
                          const data = docSnap.data();
                          const savedSources = data.sourceList;
                          if (Array.isArray(savedSources) && savedSources.length > 0) {
                              loadSources(savedSources);
                              return;
                          }
                      }
                      // If doc doesn't exist or is empty, load from manifest
                      await discoverAndLoadInitialPdfs();
                  } catch (e) {
                      console.error("Failed to load sources from Firebase, falling back to default.", e);
                      setError("Firebase에서 자료를 불러오는 데 실패했습니다. 기본값으로 대체합니다.");
                      await discoverAndLoadInitialPdfs();
                  }
              };
              loadInitialData();
          }, [discoverAndLoadInitialPdfs, loadSources, sourcesDocRef]);

          const handleSendMessage = useCallback(async (e) => {
              e.preventDefault();
              if (!currentMessage.trim() || !chatSession || isLoading) return;

              const userMessage = { role: Role.USER, content: currentMessage.trim() };
              setMessages(prev => [...prev, userMessage]);
              setCurrentMessage('');
              setIsLoading(true);
              setError(null);

              try {
                  const stream = await chatSession.sendMessageStream({ message: userMessage.content });

                  let modelResponse = '';
                  setMessages(prev => [...prev, { role: Role.MODEL, content: '' }]);

                  for await (const chunk of stream) {
                      modelResponse += chunk.text;
                      setMessages(prev => {
                          const newMessages = [...prev];
                          newMessages[newMessages.length - 1].content = modelResponse;
                          return newMessages;
                      });
                  }
              } catch (err) {
                  console.error(err);
                  const errorMessage = err instanceof Error ? err.message : 'An unknown error occurred.';
                  setError(`Failed to get response: ${errorMessage}`);
                  setMessages(prev => {
                      const newMessages = [...prev];
                      if(newMessages[newMessages.length - 1].role === Role.MODEL) newMessages.pop();
                      return [...newMessages, { role: Role.MODEL, content: `Sorry, I encountered an error. ${errorMessage}` }];
                  });
              } finally {
                  setIsLoading(false);
              }
          }, [chatSession, currentMessage, isLoading]);

          const handleToggleEditMode = () => {
              if (!isEditMode) {
                setTempSources(sources.map(s => ({ name: s.name, url: s.url })));
              }
              setIsEditMode(!isEditMode);
          };

          const handleCancelEdit = () => setIsEditMode(false);
          
          const handleSaveSources = async () => {
              try {
                  await sourcesDocRef.set({ sourceList: tempSources });
                  setIsEditMode(false);
                  loadSources(tempSources);
              } catch (e) {
                  console.error("Failed to save sources to Firebase:", e);
                  setError("Firebase에 자료를 저장하는 데 실패했습니다. 다시 시도해주세요.");
              }
          };

          const handleResetSources = async () => {
              if (window.confirm('정말로 자료 출처를 모든 사용자의 기본값으로 되돌리시겠습니까? 저장된 변경사항이 영구적으로 사라집니다.')) {
                  try {
                      const manifestUrl = `${PDF_BASE_URL}manifest.json`;
                      const manifestResponse = await fetch(manifestUrl);
                      if (!manifestResponse.ok) throw new Error(`Could not load manifest.json`);
                      const pdfFiles = await manifestResponse.json();
                      if (!Array.isArray(pdfFiles)) throw new Error("Invalid manifest.json format.");
                      
                      const defaultSources = pdfFiles.map(file => {
                          const url = PDF_BASE_URL + file;
                          return { name: getSourceName(url), url };
                      });

                      await sourcesDocRef.set({ sourceList: defaultSources });
                      
                      window.location.reload();
                  } catch (e) {
                      console.error("Failed to reset sources in Firebase:", e);
                      setError("Firebase에서 자료를 초기화하는 데 실패했습니다.");
                  }
              }
          };

          const handleAddTempSource = (name, url) => {
              if (url && (url.startsWith('http://') || url.startsWith('https://'))) {
                setTempSources(prev => [...prev, { name, url }]);
              } else {
                alert('유효한 URL을 입력해주세요 (http:// 또는 https:// 로 시작)');
              }
          };
          
          const handleRemoveTempSource = (index) => setTempSources(prev => prev.filter((_, i) => i !== index));

          const handleUpdateTempSource = (index, field, value) => {
            setTempSources(prev => prev.map((s, i) => i === index ? { ...s, [field]: value } : s));
          };

          return (
              <div className="h-screen w-screen flex flex-col p-4 gap-4 bg-brand-bg">
                  <header className="text-center">
                      <h1 className="text-2xl font-bold text-brand-text-primary">금연사업 지침 문의 Chatbot</h1>
                  </header>
                  
                  <main className="flex-1 grid grid-cols-1 md:grid-cols-2 gap-4 min-h-0">
                      <div className="flex flex-col min-h-0">
                           <SourceInfo
                                isLoading={isParsing}
                                sources={sources}
                                isEditMode={isEditMode}
                                onToggleEditMode={handleToggleEditMode}
                                tempSources={tempSources}
                                onUpdateTempSource={handleUpdateTempSource}
                                onRemoveTempSource={handleRemoveTempSource}
                                onAddTempSource={handleAddTempSource}
                                onSave={handleSaveSources}
                                onCancel={handleCancelEdit}
                                onReset={handleResetSources}
                           />
                      </div>
                      
                      <div className="flex flex-col h-full bg-brand-surface rounded-lg min-h-0">
                          <div className="flex-1 flex flex-col min-h-0">
                            <h2 className="text-lg font-semibold text-brand-primary p-4 border-b border-brand-secondary">질문하기</h2>
                              <>
                                 {error && <div className="p-4 bg-red-900/50 text-red-300 border-b border-red-700">{error}</div>}
                                 <ChatWindow 
                                     messages={messages} 
                                     isLoading={isLoading} 
                                     sourceProvided={!!chatSession}
                                     isParsingDocs={isParsing}
                                 />
                                 <MessageInput
                                      currentMessage={currentMessage}
                                      setCurrentMessage={setCurrentMessage}
                                      onSendMessage={handleSendMessage}
                                      isLoading={isLoading}
                                      disabled={!chatSession || isParsing}
                                  />
                              </>
                          </div>
                      </div>
                  </main>
              </div>
          );
      };

      // --- Inlined from index.tsx ---
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }

      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <StrictMode>
          <App />
        </StrictMode>
      );
    </script>
  </body>
</html>
